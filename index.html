<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Fourier Series Drawer</title>
  <style>
    body { margin:0; overflow:hidden; background:#202124; color:#fff; display:flex; flex-direction:column; align-items:center; }
    #controls { position:absolute; top:10px; z-index:10; }
    button { padding:8px 16px; margin-right:8px; font-size:16px; }
    canvas { border:1px solid #444; background:#fff; }
  </style>
</head>
<body>
  <div id="controls">
    <button id="clear">Clear</button>
    <button id="start">Start Fourier</button>
  </div>
  <canvas id="canvas"></canvas>
  <script>
  // Complex class for DFT
  class Complex {
    constructor(re, im) { this.re = re; this.im = im; }
    add(c) { return new Complex(this.re + c.re, this.im + c.im); }
    mul(c) { return new Complex(
        this.re * c.re - this.im * c.im,
        this.re * c.im + this.im * c.re
      ); }
  }
  // Discrete Fourier Transform
  function dft(x) {
    const X = [];
    const N = x.length;
    for (let k = 0; k < N; k++) {
      let sum = new Complex(0,0);
      for (let n = 0; n < N; n++) {
        const phi = (2 * Math.PI * k * n) / N;
        const c = new Complex(Math.cos(phi), -Math.sin(phi));
        sum = sum.add(x[n].mul(c));
      }
      sum.re /= N; sum.im /= N;
      let freq = k;
      if (k > N/2) freq = k - N;
      const amp = Math.hypot(sum.re, sum.im);
      const phase = Math.atan2(sum.im, sum.re);
      X.push({ re: sum.re, im: sum.im, freq, amp, phase });
    }
    return X.sort((a,b) => b.amp - a.amp);
  }
  // Setup canvas
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();
  let drawing = [];
  let fourier = [];
  let time = 0;
  let path = [];
  let animating = false;
  // Drawing input
  canvas.addEventListener('mousedown', () => { if (!animating) drawing = []; });
  canvas.addEventListener('mousemove', (e) => {
    if (!animating && e.buttons) {
      drawing.push({ x: e.clientX - canvas.width/2, y: e.clientY - canvas.height/2 });
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      drawing.forEach((p, i) => {
        if (i === 0) ctx.moveTo(p.x + canvas.width/2, p.y + canvas.height/2);
        else ctx.lineTo(p.x + canvas.width/2, p.y + canvas.height/2);
      });
      ctx.strokeStyle = '#ff0055'; ctx.lineWidth = 2; ctx.stroke();
    }
  });
  // Compute and start
  canvas.addEventListener('mouseup', () => {
    if (!animating && drawing.length) {
      const x = drawing.map(p => new Complex(p.x, p.y));
      fourier = dft(x);
      animating = true;
      time = 0;
      path = [];
      animate();
    }
  });
  // Controls
  document.getElementById('clear').addEventListener('click', () => {
    drawing = [];
    animating = false;
    path = [];
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });
  document.getElementById('start').addEventListener('click', () => {
    if (!animating && drawing.length) {
      const x = drawing.map(p => new Complex(p.x, p.y));
      fourier = dft(x);
      animating = true; time = 0; path = [];
      animate();
    }
  });
  // Draw epicycles and path
  function drawEpicycles(x, y, rotation, fourier) {
    fourier.forEach(f => {
      const prevx = x, prevy = y;
      x += f.amp * Math.cos(f.freq * time + f.phase + rotation);
      y += f.amp * Math.sin(f.freq * time + f.phase + rotation);
      // circle
      ctx.beginPath();
      ctx.arc(prevx + canvas.width/2, prevy + canvas.height/2, f.amp, 0, 2*Math.PI);
      ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1; ctx.stroke();
      // radius
      ctx.beginPath();
      ctx.moveTo(prevx + canvas.width/2, prevy + canvas.height/2);
      ctx.lineTo(x + canvas.width/2, y + canvas.height/2);
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
    });
    return { x, y };
  }
  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const v = drawEpicycles(0, 0, 0, fourier);
    path.unshift(v);
    // draw path
    ctx.beginPath();
    path.forEach((p, i) => {
      if (i === 0) ctx.moveTo(p.x + canvas.width/2, p.y + canvas.height/2);
      else ctx.lineTo(p.x + canvas.width/2, p.y + canvas.height/2);
    });
    ctx.strokeStyle = '#ff0055'; ctx.lineWidth = 2; ctx.stroke();
    const dt = (2 * Math.PI) / fourier.length;
    time += dt;
    if (time > 2 * Math.PI) {
      time = 0; path = [];
    }
    if (animating) requestAnimationFrame(animate);
  }
  </script>
</body>
</html>
