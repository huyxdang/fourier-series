<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Webcam ASCII Art Converter</title>
  <style>
    body { margin: 0; background: #111; color: #eee; font-family: monospace; display: flex; flex-direction: column; align-items: center; }
    #controls { margin: 1rem; display: flex; gap: 1rem; align-items: center; }
    label { font-size: 0.9rem; }
    input[type=range] { width: 150px; }
    #video, #canvas { display: none; }
    #ascii { white-space: pre; line-height: 7px; font-size: 7px; }
    #ascii.dark { background: #000; color: #0f0; }
    #ascii.light { background: #fff; color: #000; }
    button { padding: 0.5rem 1rem; background: #222; border: 1px solid #555; color: #eee; cursor: pointer; }
    button:hover { background: #333; }
  </style>
</head>
<body>
  <h1>Webcam ASCII Art Converter</h1>
  <div id="controls">
    <button id="toggleCam">Start Camera</button>
    <label>Width: <input type="range" id="widthSlider" min="40" max="200" value="100"></label>
    <label>Invert: <input type="checkbox" id="invertToggle"></label>
    <label>Chars: <input type="text" id="charSet" value="@%#*+=-:. " size="10"></label>
  </div>
  <div id="ascii" class="dark"></div>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const asciiDiv = document.getElementById('ascii');
    const toggleCamBtn = document.getElementById('toggleCam');
    const widthSlider = document.getElementById('widthSlider');
    const invertToggle = document.getElementById('invertToggle');
    const charSetInput = document.getElementById('charSet');

    let streaming = false;

    toggleCamBtn.addEventListener('click', async () => {
      if (!streaming) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          video.srcObject = stream;
          await video.play();
          streaming = true;
          toggleCamBtn.textContent = 'Stop Camera';
          renderLoop();
        } catch (err) {
          alert('Camera access denied or unavailable.');
        }
      } else {
        const tracks = video.srcObject.getTracks();
        tracks.forEach(t => t.stop());
        streaming = false;
        toggleCamBtn.textContent = 'Start Camera';
        asciiDiv.textContent = '';
      }
    });

    function renderLoop() {
      if (!streaming) return;
      const charSet = charSetInput.value || '@%#*+=-:. ';
      const invert = invertToggle.checked;
      const asciiWidth = parseInt(widthSlider.value, 10);

      const videoWidth = video.videoWidth;
      const videoHeight = video.videoHeight;
      const aspect = videoHeight / videoWidth;
      const asciiHeight = Math.round(asciiWidth * aspect * 0.5);

      canvas.width = asciiWidth;
      canvas.height = asciiHeight;
      ctx.drawImage(video, 0, 0, asciiWidth, asciiHeight);

      const imageData = ctx.getImageData(0, 0, asciiWidth, asciiHeight).data;
      let asciiStr = '';
      for (let y = 0; y < asciiHeight; y++) {
        for (let x = 0; x < asciiWidth; x++) {
          const offset = (y * asciiWidth + x) * 4;
          const r = imageData[offset];
          const g = imageData[offset + 1];
          const b = imageData[offset + 2];
          const brightness = (r + g + b) / 3;
          const norm = invert ? 255 - brightness : brightness;
          const charIndex = Math.floor((norm / 255) * (charSet.length - 1));
          asciiStr += charSet.charAt(charIndex);
        }
        asciiStr += '\n';
      }
      asciiDiv.textContent = asciiStr;
      requestAnimationFrame(renderLoop);
    }
  </script>
</body>
</html>
